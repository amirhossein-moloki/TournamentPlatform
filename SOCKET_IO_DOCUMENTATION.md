# مستندات Socket.IO پروژه

این مستند به تشریح نحوه استفاده از Socket.IO در این پروژه برای ارتباطات real-time می‌پردازد.

## فهرست مطالب

1.  [مقدمه و معماری کلی](#مقدمه-و-معماری-کلی)
2.  [احراز هویت (Authentication)](#احراز-هویت-authentication)
3.  [مدیریت اتصالات و `activeSockets`](#مدیریت-اتصالات-و-activesockets)
4.  [ماژول‌ها و Handlerها](#ماژولها-و-handlerها)
    *   [Chat Handler (`chat.handler.js`)](#chat-handler-chathandlerjs)
    *   [Notification Handler (`notification.handler.js`)](#notification-handler-notificationhandlerjs)
    *   [Tournament Handler (`tournament.handler.js`)](#tournament-handler-tournamenthandlerjs)
5.  [نحوه ارسال و دریافت پیام‌ها/رویدادها از سمت کلاینت](#نحوه-ارسال-و-دریافت-پیامهارویدادها-از-سمت-کلاینت)
6.  [ساختار اتاق‌ها (Rooms)](#ساختار-اتاقها-rooms)
7.  [نکات مهم و توسعه آینده](#نکات-مهم-و-توسعه-آینده)

---

## 1. مقدمه و معماری کلی

Socket.IO در این پروژه برای فراهم کردن قابلیت‌های ارتباطی دوطرفه و آنی (real-time) بین کلاینت‌ها و سرور استفاده می‌شود. معماری اصلی حول یک فایل مرکزی `src/presentation/sockets/index.js` سازماندهی شده است که مسئولیت‌های زیر را بر عهده دارد:

*   **راه‌اندازی سرور Socket.IO**: ایجاد نمونه‌ای از سرور Socket.IO و اتصال آن به سرور HTTP موجود.
*   **پیکربندی CORS**: تنظیم دسترسی‌های Cross-Origin Resource Sharing برای اطمینان از اینکه فقط دامنه‌های مجاز می‌توانند به سرور سوکت متصل شوند.
*   **احراز هویت مرکزی**: پیاده‌سازی یک میدل‌ور (middleware) برای احراز هویت تمام اتصالات ورودی قبل از برقراری کامل ارتباط.
*   **مدیریت چرخه عمر اتصال**: رسیدگی به رویدادهای اتصال (`connection`) و قطع اتصال (`disconnect`) هر کلاینت.
*   **ثبت Handlerهای رویداد**: پس از اتصال موفقیت‌آمیز کلاینت، handlerهای مربوط به ماژول‌های مختلف (مانند چت، نوتیفیکیشن، مسابقات) برای آن سوکت خاص ثبت می‌شوند تا به رویدادهای مربوطه گوش دهند و پاسخ دهند.
*   **ردیابی سوکت‌های فعال**: نگهداری لیستی از سوکت‌های فعال و اطلاعات مرتبط با آن‌ها.

فایل `src/presentation/sockets/index.js` به عنوان یک هماهنگ‌کننده عمل می‌کند و منطق خاص هر ماژول (مانند چت یا مسابقات) در فایل‌های جداگانه‌ای تحت عنوان `handler` در مسیر `src/presentation/sockets/handlers/` قرار دارد. این امر به ماژولار بودن و خوانایی بیشتر کد کمک می‌کند.

---

## 2. احراز هویت (Authentication)

تمامی اتصالات Socket.IO در این پروژه نیازمند احراز هویت هستند. این فرآیند توسط یک میدل‌ور که در `src/presentation/sockets/index.js` با استفاده از `io.use()` تعریف شده، انجام می‌شود.

**نحوه عملکرد:**

1.  **ارسال توکن توسط کلاینت**:
    *   کلاینت هنگام تلاش برای برقراری اتصال Socket.IO، باید یک توکن دسترسی JWT (JSON Web Token) معتبر ارسال کند.
    *   توکن ترجیحاً باید در فیلد `auth.token` در `socket.handshake` ارسال شود (روش استاندارد برای Socket.IO نسخه ۳ به بعد).
    *   به عنوان جایگزین، توکن می‌تواند در هدر `x-access-token` نیز ارسال گردد.

2.  **بررسی توکن در سرور**:
    *   میدل‌ور ابتدا بررسی می‌کند که آیا توکنی ارسال شده است یا خیر. در صورت عدم وجود توکن، اتصال با خطا رد می‌شود.
    *   در صورت وجود توکن، سرور با استفاده از `jwt.verify()` و کلید مخفی (`appConfig.jwt.secret`) اقدام به اعتبارسنجی توکن می‌کند.
    *   اگر توکن نامعتبر باشد (مثلاً منقضی شده یا امضای نادرست داشته باشد)، اتصال با خطا رد می‌شود.

3.  **ذخیره اطلاعات کاربر**:
    *   در صورت موفقیت‌آمیز بودن احراز هویت، اطلاعات کاربر که از توکن استخراج شده (مانند `id` که همان `sub` در توکن است، `email` و آرایه‌ای از `roles`) در شیء `socket.user` ذخیره می‌شود.
    *   این اطلاعات، به خصوص آرایه نقش‌ها، در ادامه توسط handlerهای مختلف برای شناسایی کاربر، بررسی مجوزها و انجام عملیات مجاز مورد استفاده قرار می‌گیرد.

**مثال (مفهومی) از سمت کلاینت برای ارسال توکن:**

```javascript
// JavaScript (Client-side)
const socket = io("http://localhost:3000", { // آدرس سرور شما
  auth: {
    token: "YOUR_JWT_ACCESS_TOKEN" // توکن JWT معتبر کاربر
  }
});

// یا با استفاده از هدر (کمتر توصیه می‌شود)
// const socket = io("http://localhost:3000", {
//   extraHeaders: {
//     "x-access-token": "YOUR_JWT_ACCESS_TOKEN"
//   }
// });
```

**نکات مهم:**

*   در حال حاضر، یک `TODO` در کد برای بررسی `tokenVersion` (در صورت پیاده‌سازی ابطال توکن از طریق موجودیت User) وجود دارد که می‌تواند امنیت را افزایش دهد.
*   در صورت بروز خطا در احراز هویت (مانند توکن نامعتبر یا منقضی شده)، پیام خطای مناسب به کلاینت ارسال شده و اتصال برقرار نمی‌شود.

---

## 3. مدیریت اتصالات و `activeSockets`

پس از موفقیت در مرحله احراز هویت، رویداد `connection` برای هر کلاینت جدید فعال می‌شود. فایل `src/presentation/sockets/index.js` این اتصالات را مدیریت کرده و اطلاعات مربوط به سوکت‌های فعال را ردیابی می‌کند.

**`activeSockets` Map:**

*   یک `Map` به نام `activeSockets` در سطح ماژول `index.js` تعریف شده است.
*   این `Map` برای نگهداری اطلاعات مربوط به تمام کلاینت‌های متصل در حال حاضر استفاده می‌شود.
*   **کلید (Key)**: `socket.id` (شناسه منحصر به فرد هر سوکت).
*   **مقدار (Value)**: یک شیء شامل اطلاعات زیر:
    *   `userId`: شناسه کاربری که از `socket.user.id` (پس از احراز هویت) گرفته می‌شود.
    *   `username`: نام کاربری یا ایمیل کاربر (از `socket.user.email`).
    *   `rooms`: یک `Set` از رشته‌ها که نام اتاق‌هایی را که این سوکت به آن‌ها پیوسته است، نگهداری می‌کند. این `Set` توسط handlerهای مختلف (مانند `chat.handler.js` یا `tournament.handler.js`) هنگام پیوستن یا ترک اتاق‌ها به‌روزرسانی می‌شود.

**رویداد `connection`:**

1.  هنگامی که یک کلاینت با موفقیت احراز هویت شده و متصل می‌شود:
    *   یک پیام اطلاعاتی در لاگ سرور ثبت می‌شود.
    *   اطلاعات سوکت جدید (شامل `userId`, `username` و یک `Set` خالی برای `rooms`) به `activeSockets` اضافه می‌شود.
    *   Handlerهای مختلف رویداد (مانند `chatHandler`, `notificationHandler`, `tournamentHandler`) برای این سوکت خاص فراخوانی و ثبت می‌شوند. این handlerها `io` (نمونه سرور)، `socket` (نمونه سوکت کلاینت) و `activeSockets` را به عنوان آرگومان دریافت می‌کنند.

**رویداد `disconnect`:**

1.  هنگامی که یک کلاینت قطع اتصال می‌دهد (به هر دلیلی مانند بسته شدن مرورگر، مشکلات شبکه، یا فراخوانی `socket.disconnect()` از سمت کلاینت):
    *   رویداد `disconnect` برای آن سوکت فعال می‌شود.
    *   یک پیام اطلاعاتی شامل دلیل قطع اتصال (در صورت وجود) در لاگ سرور ثبت می‌شود.
    *   ورودی مربوط به آن `socket.id` از `activeSockets` Map حذف می‌شود.
    *   Socket.IO به طور خودکار سوکت را از تمام اتاق‌هایی که به آن‌ها پیوسته بود، خارج می‌کند. Handlerهای خاص (مانند `chat.handler.js`) ممکن است منطق اضافی برای اطلاع‌رسانی به سایر کاربران در اتاق‌ها هنگام خروج یک کاربر داشته باشند (که معمولاً از طریق رویداد `userLeft` انجام می‌شود).

**رویداد `error` (مربوط به سوکت):**

*   یک handler برای رویداد `error` روی هر سوکت نیز تعریف شده است.
*   این handler خطاهای خاص مربوط به آن سوکت را لاگ می‌کند. بسته به نوع خطا، ممکن است نیاز به اقدامات بیشتری باشد، اما در پیاده‌سازی فعلی فقط لاگ انجام می‌شود.

**نکته در مورد مقیاس‌پذیری:**

*   استفاده از `Map` در حافظه (`activeSockets`) برای ردیابی کاربران فعال، برای یک نمونه (single instance) از برنامه مناسب است. در صورتی که برنامه روی چندین نمونه (multi-instance deployment) اجرا شود (مثلاً با استفاده از PM2 در حالت cluster یا Kubernetes)، این `Map` بین نمونه‌ها به اشتراک گذاشته نخواهد شد. برای چنین سناریوهایی، استفاده از یک راه‌حل ذخیره‌سازی مشترک مانند Redis برای نگهداری اطلاعات سوکت‌های فعال و عضویت در اتاق‌ها توصیه می‌شود. Socket.IO Adapter برای Redis (`socket.io-redis`) می‌تواند برای این منظور استفاده شود.

---

## 4. ماژول‌ها و Handlerها

این بخش به تفصیل به بررسی هر یک از handlerهای موجود در مسیر `src/presentation/sockets/handlers/` می‌پردازد. هر handler مسئول مدیریت گروهی از رویدادهای مرتبط با یک ماژول خاص است.

### Chat Handler (`chat.handler.js`)

این handler مسئول مدیریت تمام قابلیت‌های مربوط به چت در سیستم است. این شامل پیوستن و ترک کردن اتاق‌های چت، و ارسال و دریافت پیام‌ها می‌شود.

**مسئولیت‌ها:**

*   مدیریت ورود کاربران به اتاق‌های چت (`joinRoom`).
*   مدیریت خروج کاربران از اتاق‌های چت (`leaveRoom`).
*   مدیریت ارسال پیام از طرف یک کاربر به یک اتاق چت (`sendMessage`).
*   پخش پیام‌های جدید به تمام کاربران حاضر در یک اتاق (`newMessage`).
*   اطلاع‌رسانی به کاربران یک اتاق هنگام ورود (`userJoined`) یا خروج (`userLeft`) کاربر دیگر.
*   اعتبارسنجی داده‌های ورودی برای رویدادها با استفاده از کتابخانه Joi.

**رویدادهای مدیریت شده:**

#### رویدادهای دریافتی از کلاینت (Client -> Server):

1.  **`joinRoom`**
    *   **توضیحات**: کلاینت این رویداد را برای پیوستن به یک اتاق چت خاص ارسال می‌کند.
    *   **Payload ورودی**:
        ```json
        {
          "roomId": "string" // شناسه اتاق (مثلاً tournamentId, matchId)
        }
        ```
    *   **اعتبارسنجی**: از `joinRoomSchema` (تعریف شده با Joi) برای اعتبارسنجی `roomId` استفاده می‌شود.
    *   **عملکرد**:
        *   سوکت کاربر به اتاق مشخص شده با `roomId` ملحق می‌شود (`socket.join(roomId)`).
        *   `roomId` به `Set` مربوط به `rooms` در `activeSockets` برای آن سوکت اضافه می‌شود.
        *   یک پیام لاگ در سرور ثبت می‌شود.
        *   یک رویداد `userJoined` به سایر کلاینت‌های حاضر در آن اتاق ارسال می‌شود.
        *   (مفهومی) در آینده می‌تواند تاریخچه پیام‌های اخیر اتاق را برای کاربر تازه‌وارد ارسال کند.
        *   یک پاسخ (callback) به کلاینت ارسال‌کننده با وضعیت موفقیت یا شکست ارسال می‌شود.
    *   **Callback به کلاینت**:
        ```json
        // در صورت موفقیت
        { "success": true, "roomId": "string" }
        // در صورت خطا
        { "success": false, "error": "string" }
        ```

2.  **`leaveRoom`**
    *   **توضیحات**: کلاینت این رویداد را برای خروج از یک اتاق چت خاص ارسال می‌کند.
    *   **Payload ورودی**:
        ```json
        {
          "roomId": "string" // شناسه اتاقی که باید ترک شود
        }
        ```
    *   **اعتبارسنجی**: از `joinRoomSchema` (مشابه `joinRoom`) برای اعتبارسنجی `roomId` استفاده می‌شود.
    *   **عملکرد**:
        *   سوکت کاربر از اتاق مشخص شده با `roomId` خارج می‌شود (`socket.leave(roomId)`).
        *   `roomId` از `Set` مربوط به `rooms` در `activeSockets` برای آن سوکت حذف می‌شود.
        *   یک پیام لاگ در سرور ثبت می‌شود.
        *   یک رویداد `userLeft` به سایر کلاینت‌های حاضر در آن اتاق ارسال می‌شود.
        *   یک پاسخ (callback) به کلاینت ارسال‌کننده با وضعیت موفقیت یا شکست ارسال می‌شود.
    *   **Callback به کلاینت**:
        ```json
        // در صورت موفقیت
        { "success": true, "roomId": "string" }
        // در صورت خطا
        { "success": false, "error": "string" }
        ```

3.  **`sendMessage`**
    *   **توضیحات**: کلاینت این رویداد را برای ارسال یک پیام متنی به یک اتاق چت که در آن عضو است، ارسال می‌کند.
    *   **Payload ورودی**:
        ```json
        {
          "roomId": "string", // شناسه اتاق مقصد
          "text": "string"    // محتوای پیام (حداقل 1، حداکثر 1000 کاراکتر)
        }
        ```
    *   **اعتبارسنجی**: از `sendMessageSchema` (تعریف شده با Joi) برای اعتبارسنجی `roomId` و `text` استفاده می‌شود.
    *   **عملکرد**:
        *   بررسی می‌شود که آیا سوکت کاربر عضو اتاق `roomId` است یا خیر. اگر نباشد، خطا برگردانده می‌شود.
        *   یک شیء پیام با `id` منحصر به فرد (تولید شده با `uuid.v4()`), `roomId`, اطلاعات فرستنده (`userId`, `username`), `text` و `timestamp` ایجاد می‌شود.
    *   (مفهومی) در آینده باید پیام را با استفاده از `ChatMessageRepository` در دیتابیس (با ارجاع به `ChatSessionEntity` مربوطه) ذخیره کند. موجودیت‌های `ChatMessageEntity` و `ChatSessionEntity` برای این منظور طراحی شده‌اند.
    *   رویداد `newMessage` با شیء پیام ایجاد شده (مطابق با ساختار `ChatMessageEntity`)، به تمام کلاینت‌های حاضر در `roomId` (شامل خود فرستنده) ارسال می‌شود (`io.to(roomId).emit('newMessage', messageData)`).
        *   یک پیام لاگ در سرور ثبت می‌شود.
        *   یک پاسخ (callback) به کلاینت ارسال‌کننده با وضعیت موفقیت یا شکست و شناسه پیام ارسال می‌شود.
    *   **Callback به کلاینت**:
        ```json
        // در صورت موفقیت
        { "success": true, "messageId": "string" } // messageId شناسه پیام ذخیره شده در دیتابیس خواهد بود
        // در صورت خطا
        { "success": false, "error": "string" }
        ```

#### رویدادهای ارسالی به کلاینت (Server -> Client):

1.  **`newMessage`**
    *   **توضیحات**: این رویداد توسط سرور به تمام کلاینت‌های یک اتاق ارسال می‌شود وقتی پیام جدیدی در آن اتاق ارسال شده باشد. ساختار آن باید با `ChatMessageEntity` همخوانی داشته باشد.
    *   **Payload خروجی (نمونه، بر اساس `ChatMessageEntity`)**:
        ```json
        {
          "id": "string",                   // شناسه پیام (از ChatMessageEntity)
          "sessionId": "string",            // شناسه جلسه چت (roomId)
          "senderId": "string",             // شناسه کاربر یا پشتیبان فرستنده
          "senderType": "string",           // "USER" یا "SUPPORT"
          "messageContent": "string",       // محتوای پیام
          "messageType": "string",          // "TEXT", "IMAGE_URL", "SYSTEM"
          "timestamp": "string",            // (ISOString) زمان ارسال پیام
          "metadata": { "username": "string" } // مثال: نام کاربری فرستنده برای نمایش در UI
        }
        ```

2.  **`userJoined`**
    *   **توضیحات**: این رویداد توسط سرور به کلاینت‌های یک اتاق (به جز کاربر تازه‌وارد) ارسال می‌شود تا آن‌ها را از ورود یک کاربر جدید مطلع کند.
    *   **Payload خروجی**:
        ```json
        {
          "roomId": "string",   // شناسه اتاق
          "userId": "string",   // شناسه کاربری که وارد شده
          "username": "string"// نام کاربری که وارد شده
        }
        ```

3.  **`userLeft`**
    *   **توضیحات**: این رویداد توسط سرور به کلاینت‌های یک اتاق ارسال می‌شود تا آن‌ها را از خروج یک کاربر مطلع کند. این رویداد همچنین می‌تواند هنگام `disconnect` شدن یک کاربر از اتاق‌هایی که عضو بوده، ارسال شود.
    *   **Payload خروجی**:
        ```json
        {
          "roomId": "string",   // شناسه اتاق
          "userId": "string",   // شناسه کاربری که خارج شده
          "username": "string"// نام کاربری که خارج شده
        }
        ```

**اعتبارسنجی با Joi:**

*   `chat.handler.js` از Joi برای تعریف schema و اعتبارسنجی payloadهای ورودی رویدادهای `joinRoom` و `sendMessage` استفاده می‌کند. این کار به اطمینان از صحت و کامل بودن داده‌های دریافتی از کلاینت کمک می‌کند.
*   در صورت ناموفق بودن اعتبارسنجی، یک پیام خطای مناسب از طریق callback به کلاینت ارسال می‌شود.

**نکات و توسعه‌های آینده:**

*   **ذخیره‌سازی پیام‌ها**: پیاده‌سازی کامل ذخیره‌سازی پیام‌ها با استفاده از `ChatMessageRepository` و `ChatSessionEntity`. موجودیت‌های لازم برای این کار طراحی شده‌اند.
*   **مجوز دسترسی به اتاق**: پیاده‌سازی بررسی دقیق مجوز کاربر برای پیوستن به اتاق‌های چت (مثلاً بر اساس نقش کاربر، عضویت در مسابقه یا تخصیص به یک پشتیبان). این مورد با توجه به نقش‌های جدید مانند `TOURNAMENT_SUPPORT` و `GENERAL_SUPPORT` اهمیت بیشتری پیدا می‌کند.
*   **بارگذاری تاریخچه پیام**: ارسال پیام‌های اخیر اتاق به کاربری که تازه به اتاق پیوسته است، از دیتابیس.
*   **نرخ محدودیت (Rate Limiting)**: برای جلوگیری از اسپم در رویداد `sendMessage`.
*   **نشانگر "در حال تایپ" (Is Typing Indicator)**.
*   **تخصیص هوشمند چت**: پیاده‌سازی منطق برای تخصیص چت جدید به یک پشتیبان آنلاین (ابتدا `TournamentSupport` مربوط به تورنومنت (در صورت مشخص بودن)، سپس `GeneralSupport`).

### Notification Handler (`notification.handler.js`)

این handler بیشتر به منظور مدیریت ارسال نوتیفیکیشن‌ها از سمت سرور به کلاینت‌های خاص یا گروه‌هایی از کلاینت‌ها طراحی شده است. برخلاف `chat.handler.js`، کلاینت‌ها معمولاً رویدادهای زیادی به این handler ارسال نمی‌کنند، بلکه بیشتر شنونده رویدادهای ارسالی از سرور هستند.

**مسئولیت‌ها:**

*   فراهم کردن ساختاری برای ارسال نوتیفیکیشن‌های هدفمند به کاربران.
*   (به صورت نمونه) مدیریت یک رویداد از سمت کلاینت برای تایید دریافت نوتیفیکیشن (`notificationAck`).

**رویدادهای مدیریت شده:**

#### رویدادهای دریافتی از کلاینت (Client -> Server):

1.  **`notificationAck`** (نمونه)
    *   **توضیحات**: این یک رویداد نمونه است که کلاینت می‌تواند پس از دریافت و نمایش یک نوتیفیکیشن خاص، برای تایید به سرور ارسال کند.
    *   **Payload ورودی**:
        ```json
        {
          // ساختار این payload به نوع نوتیفیکیشنی که تایید می‌شود بستگی دارد.
          // می‌تواند شامل شناسه نوتیفیکیشن یا داده‌های مرتبط دیگر باشد.
          "notificationId": "string" // مثال
        }
        ```
    *   **عملکرد**:
        *   یک پیام لاگ در سرور مبنی بر تایید نوتیفیکیشن توسط کاربر ثبت می‌کند.
        *   (مفهومی) می‌تواند وضعیت "خوانده شده" نوتیفیکیشن را در دیتابیس به‌روزرسانی کند.

#### رویدادهای ارسالی به کلاینت (Server -> Client):

1.  **`notification`**
    *   **توضیحات**: این رویداد اصلی است که سرور برای ارسال نوتیفیکیشن به کلاینت(ها) استفاده می‌کند. نوتیفیکیشن‌ها می‌توانند به یک سوکت خاص (کاربر خاص) یا به یک اتاق ارسال شوند.
    *   **Payload خروجی (نمونه)**:
        ```json
        {
          "id": "string",        // شناسه منحصر به فرد نوتیفیکیشن (مثلاً uuid)
          "type": "string",      // نوع نوتیفیکیشن (e.g., 'info', 'alert', 'success', 'error', 'welcome', 'match_start')
          "message": "string",   // متن اصلی نوتیفیکیشن
          "timestamp": "Date",   // زمان ایجاد نوتیفیکیشن
          "isRead": false,       // وضعیت خوانده شدن اولیه
          // ... سایر فیلدهای مرتبط با نوع نوتیفیکیشن
          // "data": { ... }    // داده‌های اضافی، مثلاً لینک یا اطلاعات مربوط به یک رویداد خاص
        }
        ```
    *   **نحوه ارسال از سرور**:
        *   **به یک کاربر خاص (سوکت خاص)**: با استفاده از `io.to(socketId).emit('notification', payload)` انجام می‌شود. `socketId` از `activeSockets` Map بر اساس `userId` قابل پیدا کردن است.
        *   **به یک اتاق خاص**: با استفاده از `io.to(roomName).emit('notification', payload)` (مثلاً برای ارسال نوتیفیکیشن به تمام شرکت‌کنندگان یک مسابقه).
        *   **به تمام کاربران متصل (سراسری)**: با استفاده از `io.emit('notification', payload)` (کمتر رایج برای نوتیفیکیشن‌های هدفمند).

**نحوه عملکرد و نکات:**

*   **ارسال از سمت سرور**: منطق اصلی ارسال نوتیفیکیشن‌ها معمولاً توسط سایر بخش‌های برنامه (مانند سرویس‌ها، use caseها، یا event listenerهای مربوط به رویدادهای دامنه) فعال می‌شود. برای مثال، پس از تایید یک نتیجه مسابقه، یک سرویس می‌تواند نوتیفیکیشنی را برای کاربران مرتبط ارسال کند.
*   **`NotificationService` (مفهومی)**: برای مدیریت بهتر، می‌توان یک `NotificationService` ایجاد کرد که تعاملات با Socket.IO را کپسوله کرده و متدهایی برای ارسال انواع مختلف نوتیفیکیشن‌ها ارائه دهد.
*   **ذخیره‌سازی نوتیفیکیشن‌ها**: برای اینکه کاربران نوتیفیکیشن‌ها را در صورت آفلاین بودن از دست ندهند یا بتوانند تاریخچه نوتیفیکیشن‌ها را مشاهده کنند، باید آن‌ها در دیتابیس ذخیره شوند.
*   **اتاق‌های نوتیفیکیشن**: کاربران می‌توانند به اتاق‌های خاصی برای دریافت نوتیفیکیشن‌های مرتبط با موضوعات خاص بپیوندند (مثلاً اتاق `announcements` یا اتاق‌های مربوط به مسابقاتی که در آن‌ها شرکت کرده‌اند).
*   **مثال نوتیفیکیشن خوش‌آمدگویی**: کد شامل یک مثال کامنت شده برای ارسال نوتیفیکیشن خوش‌آمدگویی به کاربر پس از اتصال است، که می‌تواند در `sockets/index.js` یا اینجا پیاده‌سازی شود.

این handler بیشتر یک زیرساخت اولیه برای سیستم نوتیفیکیشن فراهم می‌کند و منطق اصلی تولید و ارسال نوتیفیکیشن‌ها در سایر لایه‌های برنامه قرار خواهد گرفت.

### Tournament Handler (`tournament.handler.js`)

این handler برای مدیریت رویدادها و آپدیت‌های آنی مربوط به مسابقات (tournaments) و بازی‌های (matches) آن‌ها طراحی شده است. کاربران می‌توانند در آپدیت‌های یک مسابقه خاص مشترک شوند تا از تغییرات وضعیت، نتایج بازی‌ها و پیشرفت براکت به‌صورت آنی مطلع شوند.

**مسئولیت‌ها:**

*   فراهم کردن امکان اشتراک (`subscribeToTournamentUpdates`) و لغو اشتراک (`unsubscribeFromTournamentUpdates`) کاربران برای دریافت آپدیت‌های یک مسابقه خاص.
*   استفاده از اتاق‌های Socket.IO با نامگذاری مشخص (مثلاً `tournament:<tournamentId>`) برای ارسال آپدیت‌های هدفمند به مشترکین آن مسابقه.
*   (به صورت مفهومی) پخش آپدیت‌های مربوط به وضعیت مسابقه، شروع بازی‌ها، تغییر امتیازات و اعلام برندگان.

**رویدادهای مدیریت شده:**

#### رویدادهای دریافتی از کلاینت (Client -> Server):

1.  **`subscribeToTournamentUpdates`**
    *   **توضیحات**: کلاینت این رویداد را برای اشتراک در آپدیت‌های آنی یک مسابقه خاص ارسال می‌کند. معمولاً پس از ورود به صفحه جزئیات یک مسابقه، این رویداد ارسال می‌شود.
    *   **Payload ورودی**:
        ```json
        {
          "tournamentId": "string" // شناسه مسابقه‌ای که کاربر می‌خواهد در آپدیت‌های آن مشترک شود
        }
        ```
    *   **اعتبارسنجی**: بررسی می‌شود که `tournamentId` معتبر و از نوع رشته باشد.
    *   **عملکرد**:
        *   (مفهومی) ابتدا باید بررسی شود که آیا مسابقه با `tournamentId` داده شده وجود دارد و آیا کاربر مجاز به مشاهده آپدیت‌های آن است (مثلاً مسابقات عمومی یا مسابقاتی که کاربر در آن شرکت کرده).
        *   نام اتاق مربوط به مسابقه به صورت `tournament:<tournamentId>` ساخته می‌شود.
        *   سوکت کاربر به این اتاق ملحق می‌شود (`socket.join(roomName)`).
        *   نام اتاق به `Set` مربوط به `rooms` در `activeSockets` برای آن سوکت اضافه می‌شود.
        *   یک پیام لاگ در سرور ثبت می‌شود.
        *   یک پاسخ (callback) به کلاینت ارسال‌کننده با وضعیت موفقیت یا شکست ارسال می‌شود.
    *   (مفهومی) پس از اشتراک موفق، سرور می‌تواند وضعیت فعلی مسابقه/براکت را برای کاربر ارسال کند (شامل فیلدهای جدید `TournamentEntity` مانند `entryFeeType`, `prizeType`, `managed_by` در صورت مرتبط بودن با نمایش کاربر).
    *   **Callback به کلاینت**:
        ```json
        // در صورت موفقیت
        { "success": true, "message": "string" }
        // در صورت خطا
        { "success": false, "error": "string" }
        ```

2.  **`unsubscribeFromTournamentUpdates`**
    *   **توضیحات**: کلاینت این رویداد را برای لغو اشتراک از آپدیت‌های یک مسابقه خاص ارسال می‌کند.
    *   **Payload ورودی**:
        ```json
        {
          "tournamentId": "string" // شناسه مسابقه‌ای که کاربر می‌خواهد اشتراک خود را لغو کند
        }
        ```
    *   **اعتبارسنجی**: بررسی می‌شود که `tournamentId` معتبر و از نوع رشته باشد.
    *   **عملکرد**:
        *   نام اتاق مربوط به مسابقه به صورت `tournament:<tournamentId>` ساخته می‌شود.
        *   سوکت کاربر از این اتاق خارج می‌شود (`socket.leave(roomName)`).
        *   نام اتاق از `Set` مربوط به `rooms` در `activeSockets` برای آن سوکت حذف می‌شود.
        *   یک پیام لاگ در سرور ثبت می‌شود.
        *   یک پاسخ (callback) به کلاینت ارسال‌کننده با وضعیت موفقیت یا شکست ارسال می‌شود.
    *   **Callback به کلاینت**:
        ```json
        // در صورت موفقیت
        { "success": true, "message": "string" }
        // در صورت خطا
        { "success": false, "error": "string" }
        ```

#### رویدادهای ارسالی به کلاینت (Server -> Client) (مفهومی):

این رویدادها توسط سرور به اتاق `tournament:<tournamentId>` مربوطه ارسال می‌شوند و تمام کلاینت‌های مشترک در آن اتاق آن‌ها را دریافت می‌کنند. منطق ارسال این رویدادها معمولاً از use caseها یا سرویس‌های مربوط به مدیریت مسابقات نشأت می‌گیرد.

1.  **`tournamentState`** (پس از اشتراک)
    *   **توضیحات**: پس از اینکه کاربر با موفقیت در آپدیت‌های یک مسابقه مشترک شد، سرور می‌تواند وضعیت کلی فعلی مسابقه را برای او ارسال کند.
    *   **Payload خروجی (نمونه، با در نظر گرفتن فیلدهای جدید `TournamentEntity`)**:
        ```json
        {
          "tournamentId": "string",
          "name": "string",
          "status": "string", // وضعیت فعلی مسابقه (e.g., REGISTRATION_OPEN, ONGOING, FINISHED)
          "entryFeeType": "string", // e.g., FREE, PAID_CASH
          "prizeType": "string",    // e.g., CASH, INGAME_ITEM
          "managed_by_usernames": ["string"], // (اختیاری) نام‌های کاربری مدیران تورنومنت
          "bracketData": { ... } // اطلاعات مربوط به براکت، بازی‌ها، شرکت‌کنندگان و ...
          // ... سایر اطلاعات مرتبط با مسابقه
        }
        ```

2.  **`bracketUpdate`**
    *   **توضیحات**: این رویداد برای اطلاع‌رسانی تغییرات در براکت مسابقه ارسال می‌شود.
    *   **Payload خروجی (نمونه، با در نظر گرفتن فیلدهای `MatchEntity`)**:
        ```json
        {
          "type": "MATCH_UPDATE", // یا نوع دیگری از آپدیت براکت
          "tournamentId": "string",
          "match": { // اطلاعات بازی آپدیت شده، مطابق با MatchEntity
            "id": "string",
            "status": "string",
            "participant1": { "id": "string", "name": "string", "score": "number" }, // MatchParticipantInfo
            "participant2": { "id": "string", "name": "string", "score": "number" }, // MatchParticipantInfo
            "winnerId": "string" // (nullable)
            // ... سایر فیلدهای MatchEntity
          },
          "nextMatch": { ... } // (اختیاری) اطلاعات بازی بعدی
        }
        ```

3.  **`tournamentStatusUpdate`**
    *   **توضیحات**: این رویداد برای اطلاع‌رسانی تغییر در وضعیت کلی مسابقه ارسال می‌شود.
    *   **Payload خروجی (نمونه)**:
        ```json
        {
          "tournamentId": "string",
          "status": "string" // وضعیت جدید مسابقه
        }
        ```

**نحوه عملکرد و نکات:**

*   **اتاق‌های اختصاصی**: هر مسابقه یک اتاق Socket.IO اختصاصی با فرمت `tournament:<tournamentId>` دارد.
*   **ارسال آپدیت‌ها از لایه Application**: منطق ارسال آپدیت‌ها باید از use caseها یا سرویس‌ها فراخوانی شود.
*   **مجوز دسترسی (Authorization)**: بررسی اینکه آیا کاربر (با توجه به نقش‌های جدید مانند `TOURNAMENT_MANAGER` یا `TOURNAMENT_SUPPORT`) مجاز به اشتراک در آپدیت‌های یک مسابقه خاص است، اهمیت دارد.
*   **آپدیت‌های پیچیده‌تر**: برای تعاملات آنی پیچیده‌تر، ممکن است نیاز به رویدادها و اتاق‌های بیشتری باشد.

این handler اساس یک سیستم اطلاع‌رسانی آنی قوی برای مسابقات را فراهم می‌کند.

---

## 5. نحوه ارسال و دریافت پیام‌ها/رویدادها از سمت کلاینت

این بخش چند نمونه کلی از نحوه تعامل کلاینت با سرور Socket.IO را با استفاده از کتابخانه کلاینت Socket.IO (`socket.io-client`) نشان می‌دهد.

**1. اتصال به سرور و احراز هویت:**

کلاینت ابتدا باید به سرور Socket.IO متصل شود و توکن JWT خود را برای احراز هویت ارسال کند.

```javascript
// JavaScript (Client-side)
import { io } from "socket.io-client";

const accessToken = "YOUR_JWT_ACCESS_TOKEN"; // توکن معتبر کاربر

const socket = io("http://localhost:YOUR_PORT", { // آدرس و پورت سرور شما
  auth: {
    token: accessToken
  },
  // transports: ['websocket'], // می‌توانید transportها را مشخص کنید (اختیاری)
});

socket.on("connect", () => {
  console.log("Successfully connected to Socket.IO server!", socket.id);
});

socket.on("connect_error", (err) => {
  console.error("Connection failed:", err.message);
  // err.message می‌تواند شامل پیام‌های خطای احراز هویت باشد
  // مانند 'Authentication error: No token provided.' یا 'Authentication error: Invalid token.'
});

socket.on("disconnect", (reason) => {
  console.log("Disconnected from server:", reason);
});
```

**2. ارسال یک رویداد به سرور (مثال: ارسال پیام در چت):**

برای ارسال داده به سرور، از متد `socket.emit()` استفاده می‌شود. می‌توانید یک تابع callback نیز به عنوان آرگومان آخر ارسال کنید تا پاسخی از سرور دریافت کنید.

```javascript
// فرض کنید کاربر می‌خواهد پیامی به اتاق 'tournament_chat_123' ارسال کند
const roomId = 'tournament_chat_123';
const messageText = 'سلام به همه!';

socket.emit('sendMessage', { roomId, text: messageText }, (response) => {
  if (response.success) {
    console.log('Message sent successfully, ID:', response.messageId);
  } else {
    console.error('Failed to send message:', response.error);
  }
});
```

**3. گوش دادن به رویدادهای ارسالی از سرور (مثال: دریافت پیام جدید):**

برای دریافت داده‌ها یا رویدادها از سرور، از متد `socket.on()` استفاده می‌شود.

```javascript
// گوش دادن به رویداد 'newMessage' که توسط chat.handler.js ارسال می‌شود
socket.on('newMessage', (messageData) => {
  console.log('New message received:', messageData);
  // در اینجا می‌توانید پیام را در UI نمایش دهید
  // messageData: { id, roomId, sender: {id, username}, text, timestamp }
});

// گوش دادن به رویداد 'notification' که توسط notification.handler.js ارسال می‌شود
socket.on('notification', (notificationData) => {
  console.log('New notification:', notificationData);
  // نمایش نوتیفیکیشن به کاربر
  // notificationData: { id, type, message, timestamp, isRead, ... }

  // (اختیاری) ارسال تاییدیه دریافت نوتیفیکیشن
  // socket.emit('notificationAck', { notificationId: notificationData.id });
});

// گوش دادن به آپدیت‌های براکت مسابقات
socket.on('bracketUpdate', (updateData) => {
  console.log('Bracket update received:', updateData);
  // به‌روزرسانی UI براکت مسابقه
});
```

**4. پیوستن و ترک کردن اتاق‌ها:**

```javascript
// پیوستن به اتاق چت یک مسابقه
const tournamentRoomId = 'tournament_chat_xyz';
socket.emit('joinRoom', { roomId: tournamentRoomId }, (response) => {
  if (response.success) {
    console.log(`Successfully joined room: ${response.roomId}`);
  } else {
    console.error(`Failed to join room ${tournamentRoomId}:`, response.error);
  }
});

// اشتراک در آپدیت‌های یک مسابقه
const tournamentIdForUpdates = 'tournament_abc';
socket.emit('subscribeToTournamentUpdates', { tournamentId: tournamentIdForUpdates }, (response) => {
  if (response.success) {
    console.log(response.message);
  } else {
    console.error('Subscription failed:', response.error);
  }
});

// برای ترک اتاق یا لغو اشتراک، رویدادهای مشابه ('leaveRoom', 'unsubscribeFromTournamentUpdates') استفاده می‌شود
```

این مثال‌ها اصول اولیه تعامل کلاینت با سرور Socket.IO را پوشش می‌دهند. نام رویدادها و ساختار payloadها باید با آنچه در handlerهای سمت سرور تعریف شده، مطابقت داشته باشد.

---

## 6. ساختار اتاق‌ها (Rooms)

Socket.IO امکان گروه‌بندی سوکت‌ها در واحدهایی به نام "اتاق" (Room) را فراهم می‌کند. این قابلیت برای ارسال پیام‌ها و رویدادها به زیرمجموعه‌ای از کلاینت‌های متصل بسیار مفید است. یک سوکت می‌تواند به چندین اتاق بپیوندد.

**نحوه استفاده از اتاق‌ها در این پروژه:**

1.  **چت (Chat Handler):**
    *   هر `roomId` که توسط کلاینت هنگام `joinRoom` ارسال می‌شود، به عنوان نام یک اتاق در نظر گرفته می‌شود. این `roomId` می‌تواند شناسه یک مسابقه، یک بازی، یا هر گروه دیگری باشد که نیاز به چت خصوصی دارد.
    *   وقتی کاربری پیامی را با `sendMessage` به یک `roomId` خاص ارسال می‌کند، سرور آن پیام را فقط به کلاینت‌هایی که به آن اتاق (`io.to(roomId).emit()`) پیوسته‌اند، ارسال می‌کند.
    *   رویدادهای `userJoined` و `userLeft` نیز به اتاق مربوطه ارسال می‌شوند.

2.  **مسابقات (Tournament Handler):**
    *   برای هر مسابقه، یک اتاق با الگوی نام‌گذاری `tournament:<tournamentId>` ایجاد می‌شود.
    *   وقتی کاربری با `subscribeToTournamentUpdates` در آپدیت‌های یک مسابقه مشترک می‌شود، سوکت او به اتاق مربوط به آن مسابقه می‌پیوندد.
    *   تمام آپدیت‌های مربوط به آن مسابقه (مانند `bracketUpdate`, `tournamentStatusUpdate`) به این اتاق خاص ارسال می‌شوند و فقط مشترکین آن مسابقه آن‌ها را دریافت می‌کنند.

3.  **نوتیفیکیشن‌ها (Notification Handler):**
    *   اگرچه نوتیفیکیشن‌ها می‌توانند به صورت مستقیم به یک `socketId` خاص ارسال شوند، اما می‌توان از اتاق‌ها نیز برای ارسال نوتیفیکیشن‌های گروهی استفاده کرد.
    *   برای مثال، می‌توان یک اتاق `announcements` برای ارسال اطلاعیه‌های عمومی به تمام کاربرانی که به این اتاق پیوسته‌اند، ایجاد کرد. یا اتاق‌هایی برای گروه‌های خاص کاربران (مثلاً `moderators_room`).

**مدیریت عضویت در اتاق‌ها:**

*   **پیوستن به اتاق**: `socket.join(roomName)`
*   **ترک اتاق**: `socket.leave(roomName)`
*   Socket.IO به طور خودکار یک سوکت را هنگام قطع اتصال (`disconnect`) از تمام اتاق‌هایی که به آن‌ها پیوسته بود، خارج می‌کند.
*   اطلاعات مربوط به اتاق‌هایی که هر سوکت عضو آن‌هاست، در `activeSockets.get(socket.id).rooms` (یک `Set`) نگهداری می‌شود. این اطلاعات توسط handlerهای مربوطه (chat, tournament) هنگام پیوستن یا ترک اتاق‌ها به‌روزرسانی می‌شود.

استفاده صحیح از اتاق‌ها به بهینه‌سازی ارسال پیام‌ها و اطمینان از اینکه داده‌ها فقط به کلاینت‌های مربوطه می‌رسند، کمک شایانی می‌کند.

---

## 7. نکات مهم و توسعه آینده

این بخش به برخی نکات کلیدی در پیاده‌سازی فعلی و زمینه‌های بالقوه برای توسعه و بهبود در آینده اشاره می‌کند.

**نکات کلیدی پیاده‌سازی فعلی:**

*   **احراز هویت مبتنی بر JWT**: تمام اتصالات نیازمند توکن JWT معتبر هستند که امنیت اولیه را فراهم می‌کند.
*   **ماژولار بودن Handlerها**: جداسازی منطق مربوط به چت، نوتیفیکیشن و مسابقات در handlerهای مجزا به سازماندهی بهتر کد کمک کرده است.
*   **استفاده از Joi برای اعتبارسنجی**: در `chat.handler.js`، از Joi برای اعتبارسنجی payloadهای ورودی استفاده شده که از ارسال داده‌های نامعتبر جلوگیری می‌کند. این الگو می‌تواند در سایر handlerها نیز به کار رود.
*   **ردیابی سوکت‌های فعال (`activeSockets`)**: یک `Map` در حافظه برای نگهداری اطلاعات سوکت‌های متصل و اتاق‌های آن‌ها استفاده می‌شود.
*   **استفاده از اتاق‌ها برای پیام‌رسانی هدفمند**: قابلیت اتاق‌های Socket.IO به خوبی برای چت و آپدیت‌های مسابقات استفاده شده است.
*   **لاگ‌گیری**: از `logger` برای ثبت رویدادهای مهم و خطاها استفاده شده که برای اشکال‌زدایی و مانیتورینگ مفید است.

**زمینه‌های توسعه و بهبود آینده (مفهومی و عملی):**

1.  **ذخیره‌سازی داده‌ها در دیتابیس:**
    *   **پیام‌های چت**: همانطور که در کامنت‌های `chat.handler.js` اشاره شده، پیام‌های چت باید در دیتابیس ذخیره شوند تا تاریخچه چت‌ها قابل بازیابی باشد.
    *   **نوتیفیکیشن‌ها**: نوتیفیکیشن‌ها باید در دیتابیس ذخیره شوند تا کاربران در صورت آفلاین بودن آن‌ها را از دست ندهند و بتوان تاریخچه نوتیفیکیشن‌ها را نمایش داد. وضعیت خوانده شدن (`isRead`) نیز باید مدیریت شود.

2.  **مجوزهای دسترسی (Authorization) پیشرفته‌تر:**
    *   **دسترسی به اتاق‌های چت**: بررسی دقیق‌تر اینکه آیا کاربر مجاز به پیوستن به `roomId` خاصی هست یا خیر (مثلاً فقط اعضای یک تیم یا شرکت‌کنندگان یک مسابقه).
    *   **اشتراک در آپدیت‌های مسابقات**: بررسی اینکه آیا مسابقه عمومی است یا کاربر باید مجوز خاصی برای دریافت آپدیت‌ها داشته باشد.

3.  **مقیاس‌پذیری با Redis:**
    *   برای محیط‌های چند نمونه‌ای (multi-instance deployment)، `activeSockets` Map و مدیریت اتاق‌ها باید با استفاده از یک آداپتور Socket.IO مانند `socket.io-redis` به Redis منتقل شود تا اطلاعات بین نمونه‌ها همگام‌سازی شود. این موضوع در کامنت‌های `sockets/index.js` نیز اشاره شده است.

4.  **سیستم نوتیفیکیشن کامل‌تر:**
    *   ایجاد یک `NotificationService` اختصاصی برای کپسوله کردن منطق ارسال نوتیفیکیشن.
    *   امکان تنظیمات نوتیفیکیشن برای کاربران (فعال/غیرفعال کردن انواع خاصی از نوتیفیکیشن‌ها).
    *   قالب‌های مختلف برای نوتیفیکیشن‌ها.

5.  **ویژگی‌های چت پیشرفته‌تر:**
    *   نشانگر "در حال تایپ" (is typing).
    *   ارسال فایل یا تصویر.
    *   ویرایش یا حذف پیام‌ها (با در نظر گرفتن مجوزها).
    *   منشن کردن کاربران.

6.  **تست‌نویسی:**
    *   نوشتن تست‌های واحد (unit tests) و تست‌های یکپارچه‌سازی (integration tests) برای handlerهای Socket.IO و منطق مربوط به آن‌ها برای اطمینان از صحت عملکرد و جلوگیری از رگرسیون.

7.  **مدیریت خطای بهتر و پاسخ‌های استاندارد:**
    *   استانداردسازی فرمت پاسخ‌های خطا در callbackها.
    *   مدیریت دقیق‌تر خطاهای احتمالی در تمام رویدادها.

8.  **اعتبارسنجی Joi در سایر Handlerها:**
    *   استفاده از Joi یا ابزار مشابه برای اعتبارسنجی payloadهای ورودی در `notification.handler.js` و `tournament.handler.js` (در صورت نیاز به دریافت داده‌های پیچیده‌تر از کلاینت).

9.  **امنیت بیشتر:**
    *   بررسی `tokenVersion` برای ابطال JWT (همانطور که در `TODO` در `sockets/index.js` اشاره شده).
    *   اعمال نرخ محدودیت (rate limiting) برای جلوگیری از abuse در رویدادهایی مانند `sendMessage`.

این موارد می‌توانند به عنوان یک نقشه راه برای بهبود و گسترش قابلیت‌های real-time پروژه در نظر گرفته شوند.
