const ApiError = require('../../../utils/ApiError');
const httpStatusCodes = require('http-status-codes');
const { Transaction } = require('../../../domain/wallet/transaction.entity'); // Assuming entity path
const { Wallet } = require('../../../domain/wallet/wallet.entity'); // Assuming entity path
// const { appConfig } = require('../../../../config/config'); // For currency or other defaults if needed

// This use case is typically triggered by a webhook from a payment gateway
// after a user has completed a payment initiated by another use case (e.g., InitializeDepositUseCase).

class ProcessDepositUseCase {
  /**
   * @param {object} walletRepository - Repository for wallet data persistence.
   * @param {object} transactionRepository - Repository for transaction data persistence.
   * @param {object} [lockManager] - Optional: for distributed lock to prevent race conditions on wallet balance.
   */
  constructor(walletRepository, transactionRepository, lockManager = null) {
    this.walletRepository = walletRepository;
    this.transactionRepository = transactionRepository;
    this.lockManager = lockManager; // For handling concurrency
  }

  /**
   * Executes the deposit processing.
   * This is called when a payment gateway confirms a successful payment.
   *
   * @param {object} depositData - Data from the payment gateway webhook.
   * @param {string} depositData.internalTransactionId - The unique ID generated by our system for this transaction.
   * @param {string} depositData.gatewayTransactionId - The transaction ID from the payment gateway.
   * @param {number} depositData.amount - The amount deposited, as confirmed by the gateway.
   * @param {string} depositData.currency - The currency of the deposit.
   * @param {string} depositData.status - The status from the gateway (e.g., 'success', 'completed').
   * @param {object} [depositData.metadata] - Additional metadata from the gateway.
   * @returns {Promise<{transaction: Transaction, wallet: Wallet}>} The updated transaction and wallet.
   * @throws {ApiError} If processing fails (e.g., transaction not found, already processed, update conflict).
   */
  async execute({ internalTransactionId, gatewayTransactionId, amount, currency, status, metadata }) {
    if (!internalTransactionId || !gatewayTransactionId || amount == null || !currency || !status) {
      throw new ApiError(httpStatusCodes.BAD_REQUEST, 'Missing required deposit data from gateway.');
    }

    // 1. Fetch the original transaction record from our database
    const existingTransaction = await this.transactionRepository.findById(internalTransactionId);

    if (!existingTransaction) {
      // This could happen if the webhook arrives before our system has fully processed
      // the initialization, or if the ID is incorrect.
      // Depending on policy, could retry, log for investigation, or reject.
      throw new ApiError(
        httpStatusCodes.NOT_FOUND,
        `Transaction with internal ID ${internalTransactionId} not found.`
      );
    }

    // 2. Idempotency Check: Ensure this webhook/transaction isn't processed multiple times
    if (existingTransaction.status === 'COMPLETED' || existingTransaction.status === 'FAILED') {
      // If gateway says success but we already marked it completed, it's likely a duplicate webhook.
      // If it was FAILED and now success, that's unusual and needs investigation.
      // For a simple idempotency, if already COMPLETED, just acknowledge.
      if (existingTransaction.status === 'COMPLETED' && status.toLowerCase() === 'success') {
        console.warn(`Duplicate webhook for already completed transaction: ${internalTransactionId}`);
        const wallet = await this.walletRepository.findById(existingTransaction.walletId);
        return { transaction: existingTransaction, wallet }; // Return existing state
      }
      throw new ApiError(
        httpStatusCodes.CONFLICT,
        `Transaction ${internalTransactionId} already processed with status: ${existingTransaction.status}.`
      );
    }

    // 3. Validate webhook data against our stored transaction (e.g., amount, currency)
    //    This is an important security step.
    if (parseFloat(existingTransaction.amount) !== parseFloat(amount)) {
      // Critical mismatch! Log and investigate. Potentially mark as fraudulent or requires manual review.
      await this.transactionRepository.update(existingTransaction.id, {
        status: 'FAILED', // Or 'SUSPICIOUS' / 'MANUAL_REVIEW'
        description: `Amount mismatch: Expected ${existingTransaction.amount}, Gateway reported ${amount}. Gateway ID: ${gatewayTransactionId}`,
        metadata: { ...existingTransaction.metadata, gatewayReportedAmount: amount, gatewayData: metadata },
      });
      throw new ApiError(httpStatusCodes.BAD_REQUEST, 'Transaction amount mismatch with gateway confirmation.');
    }
    // Similarly, check currency if your system supports multiple and it's part of the initial transaction.

    // 4. Process based on gateway status
    if (status.toLowerCase() !== 'success' && status.toLowerCase() !== 'completed') {
      // Payment failed or is pending at gateway; update our transaction status accordingly.
      const updatedFailedTransaction = await this.transactionRepository.update(existingTransaction.id, {
        status: 'FAILED', // Or map gateway status to your internal statuses
        description: `Payment gateway reported status: ${status}. Gateway ID: ${gatewayTransactionId}`,
        metadata: { ...existingTransaction.metadata, gatewayStatus: status, gatewayData: metadata },
      });
      // No wallet balance update needed for failed transactions.
      const wallet = await this.walletRepository.findById(existingTransaction.walletId);
      return { transaction: updatedFailedTransaction, wallet };
    }

    // --- Successful Payment: Update Wallet Balance and Transaction Status ---
    // This section needs to be atomic, especially the wallet balance update.
    // A distributed lock or database-level row lock is recommended here.

    let lock;
    try {
      if (this.lockManager) {
        lock = await this.lockManager.acquire(`wallet:${existingTransaction.walletId}`);
        if (!lock) {
          throw new ApiError(httpStatusCodes.SERVICE_UNAVAILABLE, 'Could not acquire lock to update wallet. Please retry.');
        }
      }

      // Fetch the wallet again, within the lock if applicable, to get the latest balance
      const wallet = await this.walletRepository.findById(existingTransaction.walletId);
      if (!wallet) {
        throw new ApiError(httpStatusCodes.NOT_FOUND, `Wallet not found for transaction ${internalTransactionId}.`);
      }

      // Update wallet balance
      const newBalance = parseFloat(wallet.balance) + parseFloat(amount);
      const updatedWallet = await this.walletRepository.update(wallet.id, { balance: newBalance });

      // Update transaction status to COMPLETED
      const updatedTransaction = await this.transactionRepository.update(existingTransaction.id, {
        status: 'COMPLETED',
        description: `Deposit successful. Gateway ID: ${gatewayTransactionId}`,
        metadata: { ...existingTransaction.metadata, gatewayTransactionId, gatewayData: metadata },
        transactionDate: new Date(), // Mark completion date
      });

      // Optionally, emit an event (e.g., WALLET_DEPOSIT_COMPLETED)
      // eventEmitter.emit('walletDepositCompleted', { userId: wallet.userId, amount, transactionId: updatedTransaction.id });

      return { transaction: updatedTransaction, wallet: updatedWallet };

    } catch (error) {
      // Handle errors during the critical update section
      // Log the error, potentially try to revert or mark for reconciliation
      console.error(`Error processing deposit for transaction ${internalTransactionId}:`, error);
      // If it's a known ApiError, rethrow it, otherwise wrap it
      if (error instanceof ApiError) throw error;
      throw new ApiError(httpStatusCodes.INTERNAL_SERVER_ERROR, 'Failed to process deposit due to an internal error.');
    } finally {
      if (this.lockManager && lock) {
        await this.lockManager.release(lock);
      }
    }
  }
}

module.exports = ProcessDepositUseCase;

// Note on LockManager:
// A simple LockManager interface might look like:
// interface LockManager {
//   acquire(resourceKey: string, timeout?: number): Promise<Lock | null>;
//   release(lock: Lock): Promise<void>;
// }
// Implementations could use Redis (Redlock), ZooKeeper, or database advisory locks.
// If not using a distributed lock, rely on database transaction isolation levels (e.g., Serializable)
// and optimistic locking mechanisms if your ORM/database supports them well for balance updates.
// For Sequelize, you can use `transaction.LOCK.UPDATE` on the wallet row.
// This use case would then need to be able to accept and use a Sequelize transaction object.
// Example with Sequelize transaction:
// async execute(..., { transaction: dbTransaction }) { /* ... */ }
// And the calling service (e.g., webhook controller) would manage the transaction lifecycle.
// sequelize.transaction(async (t) => {
//   return processDepositUseCase.execute(data, { transaction: t });
// });
// This is generally a more robust approach for atomicity than an application-level lock manager
// if all operations are within the same database.
// The current implementation uses a conceptual `lockManager` for broader applicability.
